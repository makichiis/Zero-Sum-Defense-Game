<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Zero-Sum Defense</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: white;
      text-align: center;
      font-family: sans-serif;
    }
    #textBox {
      position: fixed;
      top: 0;
      left: 0;
      width: 300px;
      height: 100vh;
      background: rgb(255*0.1,255*0.1,255*0.1); /* semi-transparent */
      color: white;
      padding: 10px;
      z-index: 10;
    }
    #menu {
      margin-top: 100px;
    }
    button {
      padding: 10px 20px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      background: #ffb400;
      color: #222;
      cursor: pointer;
      transition: background 0.2s;
      overflow: hidden;
    }
    button:hover {
      background: #ffc933;
    }
  </style>
</head>
<body>
  <h1>Zero-Sum Defense</h1>

  <!-- âœ… Start Screen -->
  <div id="menu">
    <p>Click below to start!</p>
    <button id="startBtn">New Game</button>
  </div>

  <div id="textBox"></div>

  <!-- âœ… Game Canvas -->
  <!-- <canvas id="gameCanvas" width="640" height="360"></canvas> -->

  <!-- âœ… LittleJS CDN -->
  <script src="https://unpkg.com/littlejsengine@latest/dist/littlejs.min.js"></script>



  <script>
    const gridCellCountX = 7;
    const gridCellCountY = 10;
    const cellSize = 2;
    const gridWidth = gridCellCountX * cellSize;
    const gridHeight = gridCellCountY * cellSize;
    const boardOrigin = vec2(-gridWidth/2, -gridHeight/2);

    let player;

    let hoverCell = null;
    let hoverSideCell = null;
    let messages = [];
    //let gameState = 'topActive'; // ðŸ”¹ Can toggle between "topActive" and "bottomActive"

    

    // Define a Building class
    class Building {
      constructor(x, y, health) {
        this.position = { x: Math.floor(x), y: Math.floor(y) }; // ensure integers
        this.health = health;
      }

      // Example: damage the building
      takeDamage(amount) {
        this.health = Math.max(0, this.health - amount);
      }

      // Example: check if destroyed
      isDestroyed() {
        return this.health <= 0;
      }
    }

    // Define a Player class
    class Player {
      constructor(name) {
        this.name = name;
        this.buildings = []; // list of Building instances
        this.economy = 0;
      }

      // Add a new building to the player
      addBuilding(x, y, health) {
        const building = new Building(x, y, health);
        this.buildings.push(building);
        return building;
      }

      // Remove destroyed buildings
      cleanupDestroyedBuildings() {
        this.buildings = this.buildings.filter(b => !b.isDestroyed());
      }

      // Example: get building at a specific position
      getBuildingAt(x, y) {
        return this.buildings.find(b => b.position.x === x && b.position.y === y);
      }
    }

    const TOP_ACTIVE = 'topActive';
    const BOTTOM_ACTIVE = 'bottomActive';

    const TURN_NEXUS_PLACEMENTS = 0;
    const TURN_PHASE_ECONOMY = 1;
    const TURN_PHASE_ATTACK = 2;
    const TURN_PHASE_END_TURN = 3;

    const POOL_MAXIMUM = 10;

    const BUILDING_NEXUS = { cost: 999, health: 10, count: 2 };
    const BUILDING_PYLON = { cost: 1, health: 1, count: 4 };
    const BUILDING_DIAGONAL_MIRROR = { cost: 1, health: 1, count: 4 };
    const BUILDING_HORIZONTAL_MIRROR = { cost: 1, health: 1, count: 4 };

    let gameState = {
      active: TOP_ACTIVE,
      phase: TURN_NEXUS_PLACEMENTS,
      turn: 0,
      pool: {
        economy: POOL_MAXIMUM,
        buildings: {
          NEXUS: BUILDING_NEXUS,
          PYLONS: BUILDING_PYLON,
          DIAGONAL_MIRRORS: BUILDING_DIAGONAL_MIRROR,
          HORIZONTAL_MIRROR: BUILDING_HORIZONTAL_MIRROR
        }
      },
      player_top: new Player("top"),
      player_bottom: new Player("bottom")
    }

    const maxMessages = 20, lineHeight = 20, targetYStart = 10;

    /**
     * Draw something centered in a specific grid cell.
     *
     * @param {Object} params - The configuration object.
     * @param {number} params.gx - The cell X index (0..gridCellCountX-1).
     * @param {number} params.gy - The cell Y index (0..gridCellCountY-1).
     * @param {vec2} params.gridOrigin - The world-space origin (bottom-left corner) of the grid.
     * @param {number} params.cellSize - The size of each grid cell.
     * @param {number} params.gridCols - Total number of cells along X.
     * @param {number} params.gridRows - Total number of cells along Y.
     * @param {number} [params.width=cellSize] - The width of the thing to draw (in world units).
     * @param {number} [params.height=cellSize] - The height of the thing to draw (in world units).
     * @param {Color} [params.color=new Color(1,1,1,1)] - The color to draw with.
     * @param {Image|Texture} [params.image] - Optional image or sprite to draw instead of a solid color.
     */
    function drawInGridCell({
      gx,
      gy,
      gridOrigin,
      cellSize,
      gridCols,
      gridRows,
      width = cellSize,
      height = cellSize,
      color = new Color(1, 1, 1, 1),
      image = null
    }) {
      // ðŸ§® Compute world position for the cell center
      if (gx < 0 || gx >= gridCols || gy < 0 || gy >= gridRows) {
        console.warn("drawInGridCell: cell out of bounds", gx, gy);
        return;
      }

      const cx = gridOrigin.x + gx * cellSize + cellSize / 2;
      const cy = gridOrigin.y + gy * cellSize + cellSize / 2;
      const pos = vec2(cx, cy);
      const size = vec2(width, height);

      // ðŸŸ§ Draw either a colored rect or an image
      if (image)
        drawImage(image, pos, size, color);
      else
        drawRect(pos, size, color);
    }

    // ðŸŸ© Alias for drawing inside the main grid
    function drawInMainGrid(gx, gy, options = {}) {
      drawInGridCell({
        gx,
        gy,
        gridOrigin: boardOrigin,
        cellSize,
        gridCols: gridCellCountX,
        gridRows: gridCellCountY,
        ...options
      });
    }

    // ðŸŸ§ Alias for drawing inside the side grid
    function drawInSideGrid(gx, gy, options = {}) {
      drawInGridCell({
        gx,
        gy,
        gridOrigin: sideGridOrigin,
        cellSize,
        gridCols: sideGridCols,
        gridRows: sideGridRows,
        ...options
      });
    }



    // ðŸ”¹ Coordinate conversion
    function gridToWorld(gx, gy) {
      return vec2(
        boardOrigin.x + gx * cellSize + cellSize / 2,
        boardOrigin.y + gy * cellSize + cellSize / 2
      );
    }
    function worldToGrid(worldPos) {
      const gx = Math.floor((worldPos.x - boardOrigin.x) / cellSize);
      const gy = Math.floor((worldPos.y - boardOrigin.y) / cellSize);
      return { x: gx, y: gy };
    }

    /**
     * Convert side grid (integer) coordinates â†’ world-space coordinates.
     * Returns the world-space center of the given side grid cell.
     *
     * @param {number} gx - Column index (0..sideGridCols-1)
     * @param {number} gy - Row index (0..sideGridRows-1)
     * @returns {vec2} World-space position of the cell center
     */
    function sideGridToWorld(gx, gy) {
      return vec2(
        sideGridOrigin.x + gx * cellSize + cellSize / 2,
        sideGridOrigin.y + gy * cellSize + cellSize / 2
      );
    }

    /**
     * Convert a world-space position â†’ side grid coordinates.
     * Returns integer cell indices { x, y }.
     *
     * @param {vec2} worldPos - World-space position.
     * @returns {{x: number, y: number}} Grid coordinates (integers)
     */
    function worldToSideGrid(worldPos) {
      const gx = Math.floor((worldPos.x - sideGridOrigin.x) / cellSize);
      const gy = Math.floor((worldPos.y - sideGridOrigin.y) / cellSize);
      return { x: gx, y: gy };
    }

    // ðŸ”¹ Messages
    function enqueueMessage(text) {
      messages.push({ text, y: targetYStart + messages.length * lineHeight });
      if (messages.length > maxMessages) messages.shift();
      for (let i = 0; i < messages.length; i++)
        messages[i].targetY = targetYStart + i * lineHeight;
    }
    function updateMessages() {
      const speed = 0.2;
      for (let msg of messages) {
        if (msg.targetY === undefined) msg.targetY = msg.y;
        msg.y += (msg.targetY - msg.y) * speed;
      }
    }
    function renderMessages() {
      textBox.innerHTML = '';
      for (let msg of messages) {
        const div = document.createElement('div');
        div.style.position = 'absolute';
        div.style.top = `${msg.y}px`;
        div.style.left = '10px';
        div.style.color = 'white';
        div.style.fontSize = '16px';
        div.textContent = msg.text;
        textBox.appendChild(div);
      }
    }

    // ðŸ”¹ Initialization
    function gameInit() {
      // player = new EngineObject(vec2(0, 0), vec2(cellSize * 0.8));
      // player.color = new Color(0.2, 0.8, 1);
      // player.gridPos = { x: 0, y: 0 };
      // player.targetGrid = { x: 0, y: 0 };


      mainCanvas.addEventListener('click', onCanvasClick);
      mainCanvas.addEventListener('mousemove', onCanvasMove);
      mainCanvas.addEventListener('mouseleave', () => hoverCell = null);

      // enqueueMessage("Grid duplex system initialized!");
      // enqueueMessage("Press SPACE to toggle board mode.");
      // enqueueMessage("Click cells to move player.");

      initSideGridBuildings();
    }

let sideGridBuildings = {}; // global reference

function initSideGridBuildings() {
  sideGridBuildings = {
    NEXUS: [],
    PYLON: [],
    DIAGONAL_MIRROR: [],
    HORIZONTAL_MIRROR: []
  };

  const layout = [
    // { key: 'NEXUS', count: 2, color: new Color(0.9, 0.3, 0.9) }, // purple 
    { key: 'PYLON', count: 4, color: new Color(1.0, 0.6, 0.1) }, // orange 
    { key: 'DIAGONAL_MIRROR', count: 4, color: new Color(0.4, 0.8, 1.0) }, // blue 
    { key: 'HORIZONTAL_MIRROR', count: 4, color: new Color(0.6, 1.0, 0.6) }, // green 
  ];

  // Fill cells row by row
  let gx = 0, gy = 0;
  const maxCols = sideGridCols;
  const objectSize = vec2(cellSize * 0.6);

  for (const { key, count, color } of layout) {
    for (let i = 0; i < count; i++) {
      // Flip Y so top row is at highest y
      const flippedY = (sideGridRows - 1) - gy;
      const pos = sideGridToWorld(gx, flippedY);

      // ðŸ”¹ Create visible EngineObject for this building type
      const obj = new EngineObject(pos, objectSize);
      obj.color = color;
      obj.type = key;
      obj.gridPos = { x: gx, y: gy };

      // Store it in our reference dictionary
      sideGridBuildings[key].push(obj);

      // Advance placement
      gx++;
      if (gx >= maxCols) {
        gx = 0;
        gy++;
      }
    }
  }

  enqueueMessage("Side grid EngineObjects initialized!");
}

    // ðŸ”¹ Input
    function onCanvasMove(event) {
      const rect = mainCanvas.getBoundingClientRect();
      const worldPos = screenToWorld(vec2(
        event.clientX - rect.left,
        event.clientY - rect.top
      ));

      // --- Check main grid ---
      const gMain = worldToGrid(worldPos);
      if (gMain.x >= 0 && gMain.x < gridCellCountX &&
          gMain.y >= 0 && gMain.y < gridCellCountY) {
        hoverCell = gMain;
        hoverSideCell = null;
        mainCanvas.style.cursor = 'pointer';
        return;
      }

      // --- Check side grid ---
      const gSide = worldToSideGrid(worldPos);
      if (gSide.x >= 0 && gSide.x < sideGridCols &&
          gSide.y >= 0 && gSide.y < sideGridRows) {
        hoverSideCell = gSide;
        hoverCell = null;
        mainCanvas.style.cursor = 'pointer';
        return;
      }

      // --- Not hovering any grid ---
      hoverCell = null;
      hoverSideCell = null;
      mainCanvas.style.cursor = 'default';
    }

    function onNexusPlacementPhaseClick() {
      if (gameState.active === TOP_ACTIVE) {
        if (hoverCell) {
          let grid_coords = worldToGrid({x: hoverCell.x, y: hoverCell.y});
          console.log(grid_coords);


          enqueueMessage("Player 1 has placed their Nexus.");

        }
      } else {
        if (hoverCell) {
          enqueueMessage("Player 2 has placed their Nexus.");
          gameState.player_bottom.location = worldToGrid(hoverCell.x, hoverCell.y);
          console.log(gameState.player_bottom.location);
        }
      }
    }

    // Global reference for currently selected building
    let selectedBuilding = null;

    function onEconomyPhaseClick() {
      if (!hoverSideCell) {
        // Click was not on any side grid cell
        selectedBuilding = null;
        enqueueMessage("No building selected.");
        return;
      }

      const { x: gx, y: gy } = hoverSideCell;

      // Loop through all side grid building types
      for (const key in sideGridBuildings) {
        for (const obj of sideGridBuildings[key]) {
          // Check if this object occupies the clicked side grid cell
          if (obj.gridPos.x === gx && obj.gridPos.y === gy) {
            selectedBuilding = obj;
            enqueueMessage(`${obj.type} selected!`);
            return;
          }
        }
      }

      // If we reach here, clicked an empty cell
      selectedBuilding = null;
      enqueueMessage("No building in clicked cell.");
    }

    function onAttackPhaseClick() {

    }

    function onCanvasClick() {
      if (gameState.phase == TURN_PHASE_ECONOMY) {
        onEconomyPhaseClick();
      } else if (gameState.phase == TURN_PHASE_ATTACK) {
        onAttackPhaseClick();
      } else if (gameState.phase == TURN_NEXUS_PLACEMENTS) {
        onNexusPlacementPhaseClick();
      }
    }

    document.addEventListener('keydown', e => {
      // if (e.code === 'Space') {
      //   gameState.active = (gameState.active === TOP_ACTIVE) ? BOTTOM_ACTIVE : TOP_ACTIVE;
      //   enqueueMessage(`Switched to state: ${gameState}`);  
      // }
    });

    function isSideGridObjectVisible(obj) {
      const halfY = Math.floor(gridCellCountY / 2);

      if (gameState.active === TOP_ACTIVE) {
        // Top half active â†’ only show objects above halfY
        return obj.gridPos.y >= halfY;
      } else {
        // Bottom half active â†’ only show objects below halfY
        return obj.gridPos.y < halfY;
      }
    }

    function updateSideGridVisibility() {
        const topActive = gameState.active === TOP_ACTIVE;

        // define horizontal and vertical halves
        const halfY = Math.floor(gridCellCountY / 2);
        const halfX = Math.floor(gridCellCountX); // assuming full width counts

        for (const key in sideGridBuildings) {
            for (const obj of sideGridBuildings[key]) {
                // Compute main grid coordinates
                const mainGridY = Math.floor((obj.pos.y - boardOrigin.y) / cellSize);
                const mainGridX = Math.floor((obj.pos.x - boardOrigin.x) / cellSize);

                // Check if obj is inside main grid horizontally
                const inX = mainGridX >= 0 && mainGridX < gridCellCountX;

                if (!inX) continue;
                if (topActive) {
                    // top active â†’ bottom side invisible if inside main grid
                    obj.color.a = (mainGridY < halfY) ? 0 : 1;
                } else {
                    // bottom active â†’ top side invisible if inside main grid
                    obj.color.a = (mainGridY >= halfY) ? 0 : 1;
                }
            }
        }
    }

    // ðŸ”¹ Update
    function gameUpdate() {
      // const moveSpeed = 0.08;
      // const targetWorld = gridToWorld(player.targetGrid.x, player.targetGrid.y);
      // player.pos = player.pos.lerp(targetWorld, moveSpeed);
      // player.gridPos = worldToGrid(player.pos);
      updateSideGridVisibility(); 
    }

    // ðŸ”¹ Render helpers
    function drawGridLines() {
      const gridColor = new Color(0.4, 0.4, 0.4);
      for (let x = 0; x <= gridCellCountX; x++)
        drawLine(
          vec2(boardOrigin.x + x * cellSize, boardOrigin.y),
          vec2(boardOrigin.x + x * cellSize, boardOrigin.y + gridCellCountY * cellSize),
          0.05,
          gridColor
        );
      for (let y = 0; y <= gridCellCountY; y++)
        drawLine(
          vec2(boardOrigin.x, boardOrigin.y + y * cellSize),
          vec2(boardOrigin.x + gridCellCountX * cellSize, boardOrigin.y + y * cellSize),
          0.05,
          gridColor
        );
    }

    // ðŸ”¹ Diagonal line pattern over shaded cells
    function drawDiagonalOverlay(xStart, yStart, xEnd, yEnd, color) {
      const spacing = 0.5;
      for (let y = boardOrigin.y + yStart * cellSize; y < boardOrigin.y + yEnd * cellSize + gridHeight; y += spacing) {
        drawLine(
          vec2(boardOrigin.x + xStart * cellSize, y),
          vec2(boardOrigin.x + xEnd * cellSize, y - gridWidth),
          0.05,
          color
        );
      }
    }

    // TODO: Refactor top/bottom active board to only draw differences not same things (dont repeat yourself lmao)

    // ðŸ”¹ Board render for "topActive"
    function renderTopActiveBoard() {
      drawRect(vec2(0, 0), mainCanvasSize, new Color(0.1, 0.1, 0.1));
      drawGridLines();

      const halfY = Math.floor(gridCellCountY / 2);
      const darkColor = new Color(0, 0, 0, 0.4);

      drawRect(
        vec2(0, boardOrigin.y + (halfY * cellSize) / 2),
        vec2(gridWidth, gridHeight / 2),
        darkColor
      );

      // Add diagonal pattern
      // drawDiagonalOverlay(0, 0, gridCellCountX, gridCellCountY-10, new Color(0.7, 0.7, 0.7, 0.1));
    }

    // ðŸ”¹ Board render for "bottomActive"
    function renderBottomActiveBoard () {
      // Base grid
      drawRect(vec2(0, 0), mainCanvasSize, new Color(0.1, 0.1, 0.1));
      drawGridLines();

      const halfY = Math.floor(gridCellCountY / 2);
      const darkColor = new Color(0, 0, 0, 0.4);

      drawRect(
        vec2(0, boardOrigin.y + (halfY * cellSize) + (gridHeight / 4)),
        vec2(gridWidth, gridHeight / 2),
        darkColor
      );

      // Add diagonal pattern
      // drawDiagonalOverlay(0, halfY, gridCellCountX, gridCellCountY, new Color(0.7, 0.7, 0.7, 0.1));
    }

    // side grid

    const sideGridCols = 2;
    const sideGridRows = 6;
    const sideGridWidth = sideGridCols * cellSize;
    const sideGridHeight = sideGridRows * cellSize;
    const sideGridOrigin = vec2(
      boardOrigin.x + gridWidth + cellSize * 2,  // small gap
      boardOrigin.y
    );

    // function drawSideGrid() {
    //   const gridColor = new Color(1, 1, 1, 0.25);
    //   for (let x = 0; x <= sideGridCols; x++)
    //     drawLine(
    //       vec2(sideGridOrigin.x + x * cellSize, sideGridOrigin.y),
    //       vec2(sideGridOrigin.x + x * cellSize, sideGridOrigin.y + sideGridHeight),
    //       0.03, gridColor
    //     );
    //   for (let y = 0; y <= sideGridRows; y++)
    //     drawLine(
    //       vec2(sideGridOrigin.x, sideGridOrigin.y + y * cellSize),
    //       vec2(sideGridOrigin.x + sideGridWidth, sideGridOrigin.y + y * cellSize),
    //       0.03, gridColor
    //     );

    //   // transparent background
    //   drawRect(
    //     vec2(sideGridOrigin.x + sideGridWidth/2, sideGridOrigin.y + sideGridHeight/2),
    //     vec2(sideGridWidth, sideGridHeight),
    //     new Color(1,1,1,0.05)
    //   );
    // }

    function drawSideGrid() {
      const gridColor = new Color(1, 1, 1, 0.25);
      for (let x = 0; x <= sideGridCols; x++)
        drawLine(
          vec2(sideGridOrigin.x + x * cellSize, sideGridOrigin.y),
          vec2(sideGridOrigin.x + x * cellSize, sideGridOrigin.y + sideGridHeight),
          0.03, gridColor
        );
      for (let y = 0; y <= sideGridRows; y++)
        drawLine(
          vec2(sideGridOrigin.x, sideGridOrigin.y + y * cellSize),
          vec2(sideGridOrigin.x + sideGridWidth, sideGridOrigin.y + y * cellSize),
          0.03, gridColor
        );

      // transparent background
      drawRect(
        vec2(sideGridOrigin.x + sideGridWidth/2, sideGridOrigin.y + sideGridHeight/2),
        vec2(sideGridWidth, sideGridHeight),
        new Color(1,1,1,0.05)
      );

      // drawInSideGrid(1, 4, {
      //   width: cellSize * 0.4,
      //   height: cellSize * 0.4,
      //   color: new Color(1, 0.5, 0, 1)
      // });


      // // ðŸŸ§ Draw orange square at center of each cell
      // const orange = new Color(1, 0.5, 0, 1);
      // const squareSize = cellSize * 0.4; // smaller than full cell
      // for (let x = 0; x < sideGridCols; x++) {
      //   for (let y = 0; y < sideGridRows; y++) {
      //     const cx = sideGridOrigin.x + x * cellSize + cellSize / 2;
      //     const cy = sideGridOrigin.y + y * cellSize + cellSize / 2;
      //     drawRect(vec2(cx, cy), vec2(squareSize, squareSize), orange);
      //   }
      // }
    }

    const color_player_top_hover = new Color(0.2, 0.6, 1, 0.6); 
    const color_player_bottom_hover = new Color(0.9, 0.45, 0.0, 0.6);


    // ðŸ”¹ Main render
    function gameRender() {
      if (gameState.active == TOP_ACTIVE)
        renderTopActiveBoard();
      else if (gameState.active == BOTTOM_ACTIVE)
        renderBottomActiveBoard();
      else 
        console.log("fat ough")

      if (hoverCell) {
        const c = gridToWorld(hoverCell.x, hoverCell.y);
        drawRect(c, vec2(cellSize, cellSize), gameState.active === TOP_ACTIVE ? color_player_top_hover : color_player_bottom_hover);
      } else if (hoverSideCell) {
        const c = sideGridToWorld(hoverSideCell.x, hoverSideCell.y);
        drawRect(c, vec2(cellSize, cellSize), gameState.active === TOP_ACTIVE ? color_player_top_hover : color_player_bottom_hover);
      }

      drawSideGrid();

      updateMessages();
    }


    function gameRenderPost() {
        renderMessages();

        const phase_labels = ['NEXUS PLACEMENT', 'ECONOMY', 'ATTACK'];

        const gridInfo = `Grid: Player ${gameState.active === TOP_ACTIVE ? '1 (Top)' : '2 (Bottom)'} | Phase: ${phase_labels[gameState.phase]} | Turn: ${gameState.turn}`;
        drawText(gridInfo, vec2(-gridWidth / 2, gridHeight / 2 + 1), 0.5, new Color(1, 1, 1));

        drawText(`Pool (Economy: ${gameState.pool.economy})`, 
            vec2(sideGridOrigin.x + sideGridWidth / 2, sideGridOrigin.y + sideGridHeight + 0.5),
            0.5, new Color(1, 1, 1, 0.6)
        );

        const side_labels = ['Horizontal Mirrors (Cost: 1E/ea)', '', 'Diagonal Mirrors (Cost: 1E/ea)', '', 'Pylons (Cost: 1E/ea)', '','Nexus Pieces']

        // Draw text to the right of each grid row
        for (let row = 0; row < sideGridRows; row++) {
          const y = sideGridOrigin.y + row * cellSize + cellSize / 2; // center of the row
          const x = sideGridOrigin.x + sideGridWidth + 0.2; // just right of the side grid
          drawText(`${side_labels[row]}`, vec2(x + 5, y), 0.4, new Color(1, 1, 0.5)); // yellowish text
        }
      }

    document.getElementById('startBtn').addEventListener('click', () => {
      document.getElementById('menu').style.display = 'none';
      engineInit(gameInit, gameUpdate, gameRender, gameRenderPost);
      // enqueueMessage("Player 1 is placing their Nexus.");
    });
  </script>
</body>
</html>
