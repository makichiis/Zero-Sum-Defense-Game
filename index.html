<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Zero-Sum Defense</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: white;
      text-align: center;
      font-family: sans-serif;
    }
    #textBox {
      position: fixed;
      top: 0;
      left: 0;
      width: 300px;
      height: 100vh;
      background: rgb(255*0.1,255*0.1,255*0.1); /* semi-transparent */
      color: white;
      padding: 10px;
      z-index: 10;
    }
    #menu {
      margin-top: 100px;
    }
    button {
      padding: 10px 20px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      background: #ffb400;
      color: #222;
      cursor: pointer;
      transition: background 0.2s;
      overflow: hidden;
    }
    button:hover {
      background: #ffc933;
    }
  </style>
</head>
<body>
  <h1>LittleJS + VanillaJS Grid Demo</h1>

  <!-- âœ… Start Screen -->
  <div id="menu">
    <p>Click below to start!</p>
    <button id="startBtn">New Game</button>
  </div>

  <div id="textBox"></div>

  <!-- âœ… Game Canvas -->
  <!-- <canvas id="gameCanvas" width="640" height="360"></canvas> -->

  <!-- âœ… LittleJS CDN -->
  <script src="https://unpkg.com/littlejsengine@latest/dist/littlejs.min.js"></script>



  <script>
    const gridCellCountX = 7;
    const gridCellCountY = 10;
    const cellSize = 2;
    const gridWidth = gridCellCountX * cellSize;
    const gridHeight = gridCellCountY * cellSize;
    const boardOrigin = vec2(-gridWidth/2, -gridHeight/2);

    let player;

    let hoverCell = null;
    let messages = [];
    //let gameState = 'topActive'; // ðŸ”¹ Can toggle between "topActive" and "bottomActive"

    

    // Define a Building class
    class Building {
      constructor(x, y, health) {
        this.position = { x: Math.floor(x), y: Math.floor(y) }; // ensure integers
        this.health = health;
      }

      // Example: damage the building
      takeDamage(amount) {
        this.health = Math.max(0, this.health - amount);
      }

      // Example: check if destroyed
      isDestroyed() {
        return this.health <= 0;
      }
    }

    // Define a Player class
    class Player {
      constructor(name) {
        this.name = name;
        this.buildings = []; // list of Building instances
        this.economy = 0;
      }

      // Add a new building to the player
      addBuilding(x, y, health) {
        const building = new Building(x, y, health);
        this.buildings.push(building);
        return building;
      }

      // Remove destroyed buildings
      cleanupDestroyedBuildings() {
        this.buildings = this.buildings.filter(b => !b.isDestroyed());
      }

      // Example: get building at a specific position
      getBuildingAt(x, y) {
        return this.buildings.find(b => b.position.x === x && b.position.y === y);
      }
    }

    const TOP_ACTIVE = 'topActive';
    const BOTTOM_ACTIVE = 'bottomActive';

    const TURN_NEXUS_PLACEMENTS = 0;
    const TURN_PHASE_ECONOMY = 1;
    const TURN_PHASE_ATTACK = 2;

    const POOL_MAXIMUM = 10;

    const BUILDING_NEXUS = { cost: 999, health: 10, count: 2 };
    const BUILDING_PYLON = { cost: 1, health: 1, count: 4 };
    const BUILDING_DIAGONAL_MIRROR = { cost: 1, health: 1, count: 4 };
    const BUILDING_HORIZONTAL_MIRROR = { cost: 1, health: 1, count: 4 };

    let gameState = {
      active: TOP_ACTIVE,
      phase: TURN_NEXUS_PLACEMENTS,
      turn: 0,
      pool: {
        economy: POOL_MAXIMUM,
        buildings: {
          NEXUS: BUILDING_NEXUS,
          PYLONS: BUILDING_PYLON,
          DIAGONAL_MIRRORS: BUILDING_DIAGONAL_MIRROR,
          HORIZONTAL_MIRROR: BUILDING_HORIZONTAL_MIRROR
        }
      },
      player_top: new Player("top"),
      player_bottom: new Player("bottom")
    }

    const maxMessages = 20, lineHeight = 20, targetYStart = 10;

    // ðŸ”¹ Coordinate conversion
    function gridToWorld(gx, gy) {
      return vec2(
        boardOrigin.x + gx * cellSize + cellSize / 2,
        boardOrigin.y + gy * cellSize + cellSize / 2
      );
    }
    function worldToGrid(worldPos) {
      const gx = Math.floor((worldPos.x - boardOrigin.x) / cellSize);
      const gy = Math.floor((worldPos.y - boardOrigin.y) / cellSize);
      return { x: gx, y: gy };
    }

    // ðŸ”¹ Messages
    function enqueueMessage(text) {
      messages.push({ text, y: targetYStart + messages.length * lineHeight });
      if (messages.length > maxMessages) messages.shift();
      for (let i = 0; i < messages.length; i++)
        messages[i].targetY = targetYStart + i * lineHeight;
    }
    function updateMessages() {
      const speed = 0.2;
      for (let msg of messages) {
        if (msg.targetY === undefined) msg.targetY = msg.y;
        msg.y += (msg.targetY - msg.y) * speed;
      }
    }
    function renderMessages() {
      textBox.innerHTML = '';
      for (let msg of messages) {
        const div = document.createElement('div');
        div.style.position = 'absolute';
        div.style.top = `${msg.y}px`;
        div.style.left = '10px';
        div.style.color = 'white';
        div.style.fontSize = '16px';
        div.textContent = msg.text;
        textBox.appendChild(div);
      }
    }

    // ðŸ”¹ Initialization
    function gameInit() {
      player = new EngineObject(vec2(0, 0), vec2(cellSize * 0.8));
      player.color = new Color(0.2, 0.8, 1);
      player.gridPos = { x: 0, y: 0 };
      player.targetGrid = { x: 0, y: 0 };

      mainCanvas.addEventListener('click', onCanvasClick);
      mainCanvas.addEventListener('mousemove', onCanvasMove);
      mainCanvas.addEventListener('mouseleave', () => hoverCell = null);

      enqueueMessage("Grid duplex system initialized!");
      enqueueMessage("Press SPACE to toggle board mode.");
      enqueueMessage("Click cells to move player.");
    }

    // ðŸ”¹ Input
    function onCanvasMove(event) {
      const rect = mainCanvas.getBoundingClientRect();
      const worldPos = screenToWorld(vec2(
        event.clientX - rect.left,
        event.clientY - rect.top
      ));
      const g = worldToGrid(worldPos);

      if (g.x >= 0 && g.x < gridCellCountX && g.y >= 0 && g.y < gridCellCountY) {
        hoverCell = g;
        mainCanvas.style.cursor = 'pointer';
      } else {
        hoverCell = null;
        mainCanvas.style.cursor = 'default';
      }
    }

    function onCanvasClick() {
      if (!hoverCell) return;
      player.targetGrid = { ...hoverCell };
      enqueueMessage(`Move to grid (${hoverCell.x}, ${hoverCell.y})`);
    }

    document.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        gameState.active = (gameState.active === TOP_ACTIVE) ? BOTTOM_ACTIVE : TOP_ACTIVE;
        enqueueMessage(`Switched to state: ${gameState}`);
      }
    });

    // ðŸ”¹ Update
    function gameUpdate() {
      const moveSpeed = 0.08;
      const targetWorld = gridToWorld(player.targetGrid.x, player.targetGrid.y);
      player.pos = player.pos.lerp(targetWorld, moveSpeed);
      player.gridPos = worldToGrid(player.pos);
    }

    // ðŸ”¹ Render helpers
    function drawGridLines() {
      const gridColor = new Color(0.4, 0.4, 0.4);
      for (let x = 0; x <= gridCellCountX; x++)
        drawLine(
          vec2(boardOrigin.x + x * cellSize, boardOrigin.y),
          vec2(boardOrigin.x + x * cellSize, boardOrigin.y + gridCellCountY * cellSize),
          0.05,
          gridColor
        );
      for (let y = 0; y <= gridCellCountY; y++)
        drawLine(
          vec2(boardOrigin.x, boardOrigin.y + y * cellSize),
          vec2(boardOrigin.x + gridCellCountX * cellSize, boardOrigin.y + y * cellSize),
          0.05,
          gridColor
        );
    }

    // ðŸ”¹ Diagonal line pattern over shaded cells
    function drawDiagonalOverlay(xStart, yStart, xEnd, yEnd, color) {
      const spacing = 0.5;
      for (let y = boardOrigin.y + yStart * cellSize; y < boardOrigin.y + yEnd * cellSize + gridHeight; y += spacing) {
        drawLine(
          vec2(boardOrigin.x + xStart * cellSize, y),
          vec2(boardOrigin.x + xEnd * cellSize, y - gridWidth),
          0.05,
          color
        );
      }
    }

    // ðŸ”¹ Board render for "topActive"
    function renderTopActiveBoard() {
      drawRect(vec2(0, 0), mainCanvasSize, new Color(0.1, 0.1, 0.1));
      drawGridLines();

      const halfY = Math.floor(gridCellCountY / 2);
      const darkColor = new Color(0, 0, 0, 0.4);

      drawRect(
        vec2(0, boardOrigin.y + (halfY * cellSize) / 2),
        vec2(gridWidth, gridHeight / 2),
        darkColor
      );

      // Add diagonal pattern
      // drawDiagonalOverlay(0, 0, gridCellCountX, gridCellCountY-10, new Color(0.7, 0.7, 0.7, 0.1));
    }

    // ðŸ”¹ Board render for "bottomActive"
    function renderBottomActiveBoard () {
      // Base grid
      drawRect(vec2(0, 0), mainCanvasSize, new Color(0.1, 0.1, 0.1));
      drawGridLines();

      const halfY = Math.floor(gridCellCountY / 2);
      const darkColor = new Color(0, 0, 0, 0.4);

      drawRect(
        vec2(0, boardOrigin.y + (halfY * cellSize) + (gridHeight / 4)),
        vec2(gridWidth, gridHeight / 2),
        darkColor
      );

      // Add diagonal pattern
      // drawDiagonalOverlay(0, halfY, gridCellCountX, gridCellCountY, new Color(0.7, 0.7, 0.7, 0.1));
    }

    // side grid

    const sideGridCols = 2;
    const sideGridRows = 8;
    const sideGridWidth = sideGridCols * cellSize;
    const sideGridHeight = sideGridRows * cellSize;
    const sideGridOrigin = vec2(
      boardOrigin.x + gridWidth + cellSize * 2,  // small gap
      boardOrigin.y
    );

    function drawSideGrid() {
      const gridColor = new Color(1, 1, 1, 0.25);
      for (let x = 0; x <= sideGridCols; x++)
        drawLine(
          vec2(sideGridOrigin.x + x * cellSize, sideGridOrigin.y),
          vec2(sideGridOrigin.x + x * cellSize, sideGridOrigin.y + sideGridHeight),
          0.03, gridColor
        );
      for (let y = 0; y <= sideGridRows; y++)
        drawLine(
          vec2(sideGridOrigin.x, sideGridOrigin.y + y * cellSize),
          vec2(sideGridOrigin.x + sideGridWidth, sideGridOrigin.y + y * cellSize),
          0.03, gridColor
        );

      // transparent background
      drawRect(
        vec2(sideGridOrigin.x + sideGridWidth/2, sideGridOrigin.y + sideGridHeight/2),
        vec2(sideGridWidth, sideGridHeight),
        new Color(1,1,1,0.05)
      );
    }

    // ðŸ”¹ Main render
    function gameRender() {
      if (gameState.active == TOP_ACTIVE)
        renderTopActiveBoard();
      else if (gameState.active == BOTTOM_ACTIVE)
        renderBottomActiveBoard();
      else 
        console.log("fat ough")

      if (hoverCell) {
        const c = gridToWorld(hoverCell.x, hoverCell.y);
        drawRect(c, vec2(cellSize, cellSize), new Color(0.2, 0.6, 1, 0.3));
      }

      drawSideGrid();

      updateMessages();
    }

    function gameRenderPost() {
      drawRect(player.pos, player.size, player.color);
      renderMessages();

      const gridInfo = `Grid: (${player.gridPos.x}, ${player.gridPos.y}) | State: ${gameState}`;
      drawText(gridInfo, vec2(-gridWidth/2, gridHeight/2 + 1), 0.5, new Color(1,1,1));

      drawText(`Pool (Economy: ${gameState.pool.economy})`, 
        vec2(sideGridOrigin.x + sideGridWidth/2, sideGridOrigin.y + sideGridHeight + 0.5),
        0.5, new Color(1,1,1,0.6)
      );
    }

    document.getElementById('startBtn').addEventListener('click', () => {
      document.getElementById('menu').style.display = 'none';
      engineInit(gameInit, gameUpdate, gameRender, gameRenderPost);
    });
  </script>
</body>
</html>
